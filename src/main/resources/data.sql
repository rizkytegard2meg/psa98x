-- ----------------------------
-- Records of admin_user
-- ----------------------------
INSERT INTO `admin_user` VALUES ('1', 'admin', '24f251cb9569d43975c1feebb0a61c02', '1996-11-20', '摆码王子', 'zhengbaole_1996@163.com', 'http://github.com/JamesZBL', '1146556298', 'wechat', 'Programming', null, null, '', '2017-12-04 13:07:32', '2018-01-25 20:51:17');

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES ('23', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');
INSERT INTO `article` VALUES ('24', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');
INSERT INTO `article` VALUES ('25', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');
INSERT INTO `article` VALUES ('26', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');
INSERT INTO `article` VALUES ('27', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');
INSERT INTO `article` VALUES ('28', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');
INSERT INTO `article` VALUES ('29', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');
INSERT INTO `article` VALUES ('30', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');
INSERT INTO `article` VALUES ('35', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-13 21:01:05', '2017-12-13 21:01:05');
INSERT INTO `article` VALUES ('36', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');
INSERT INTO `article` VALUES ('37', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');
INSERT INTO `article` VALUES ('38', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');
INSERT INTO `article` VALUES ('39', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');
INSERT INTO `article` VALUES ('40', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');
INSERT INTO `article` VALUES ('41', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-13 21:10:15', '2017-12-13 21:10:15');
INSERT INTO `article` VALUES ('42', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');
INSERT INTO `article` VALUES ('43', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');
INSERT INTO `article` VALUES ('44', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');
INSERT INTO `article` VALUES ('45', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');
INSERT INTO `article` VALUES ('46', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-13 21:01:05', '2017-12-13 21:01:05');
INSERT INTO `article` VALUES ('47', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');
INSERT INTO `article` VALUES ('48', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');
INSERT INTO `article` VALUES ('49', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');
INSERT INTO `article` VALUES ('50', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');
INSERT INTO `article` VALUES ('51', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');
INSERT INTO `article` VALUES ('52', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');
INSERT INTO `article` VALUES ('53', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');
INSERT INTO `article` VALUES ('54', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');
INSERT INTO `article` VALUES ('55', 'a', '222d', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><p> ab</p>\r\n</div>', 'ab从发24', '2017-12-16 15:37:08', '2017-12-16 15:44:07');
INSERT INTO `article` VALUES ('56', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');
INSERT INTO `article` VALUES ('57', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-13 21:01:05', '2017-12-13 21:01:05');
INSERT INTO `article` VALUES ('58', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');
INSERT INTO `article` VALUES ('59', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');
INSERT INTO `article` VALUES ('60', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');
INSERT INTO `article` VALUES ('61', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');
INSERT INTO `article` VALUES ('62', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');
INSERT INTO `article` VALUES ('63', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');
INSERT INTO `article` VALUES ('64', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');
INSERT INTO `article` VALUES ('65', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');
INSERT INTO `article` VALUES ('66', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');
INSERT INTO `article` VALUES ('67', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');

-- ----------------------------
-- Records of article_copy
-- ----------------------------
INSERT INTO `article_copy` VALUES ('22', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-10 12:42:25', '2017-12-10 12:42:25');
INSERT INTO `article_copy` VALUES ('23', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');
INSERT INTO `article_copy` VALUES ('24', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');
INSERT INTO `article_copy` VALUES ('25', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');
INSERT INTO `article_copy` VALUES ('26', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');
INSERT INTO `article_copy` VALUES ('27', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');
INSERT INTO `article_copy` VALUES ('28', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');
INSERT INTO `article_copy` VALUES ('29', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');
INSERT INTO `article_copy` VALUES ('30', '面向对象软件设计模式（一）- 单例模式', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', '<div class=\"markdown-body editormd-preview-container\" previewcontainer=\"true\" style=\"padding: 20px;\"><h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？<br>作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~</p>\r\n<h2 id=\"h2--\"><a name=\"什么是单例？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单例？</h2><p>单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。</p>\r\n<blockquote>\r\n<ul>\r\n<li>保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。</li><li>这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u5B9Eu4F8B\"><a name=\"实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例</h2><blockquote>\r\n<p>在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程</p>\r\n</blockquote>\r\n<h2 id=\"h2-u6A21u5F0Fu5206u6790\"><a name=\"模式分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>模式分析</h2><blockquote>\r\n<p>先来看最简单的写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L3\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Single</span><span class=\"pun\">();</span></code></li><li class=\"L5\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L7\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L8\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>稍作修改，把构造器改为私有的，防止被外部的类调用</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了</p>\r\n<p>在 getInstance() 方法上添加 synchronized 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L6\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L7\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L8\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率</p>\r\n<p>这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例</p>\r\n<p>这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 A</span></code></li><li class=\"L1\"><code><span class=\"pln\">a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 B</span></code></li><li class=\"L2\"><code><span class=\"kwd\">int</span><span class=\"pln\"> b </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">5</span><span class=\"pun\">;</span><span class=\"pln\">      </span><span class=\"com\">//语句 C</span></code></li><li class=\"L3\"><code><span class=\"kwd\">int</span><span class=\"pln\"> c </span><span class=\"pun\">=</span><span class=\"pln\"> a </span><span class=\"pun\">+</span><span class=\"pln\"> b</span><span class=\"pun\">;</span><span class=\"pln\">  </span><span class=\"com\">//语句 D</span></code></li></ol></pre><blockquote>\r\n<p>可能会被重排成 A-C-B-D 或者 C-A-B-D</p>\r\n<p>语句 C 和语句 D 不具备原子性，因此也有可能被重排<br>getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错</p>\r\n<p>于是有了最终版本，添加 volatile 关键字</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">volatile</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{}</span></code></li><li class=\"L3\"><code><span class=\"pln\">    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> getInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L4\"><code><span class=\"pln\">        </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L5\"><code><span class=\"pln\">            </span><span class=\"kwd\">synchronized</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"kwd\">class</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L6\"><code><span class=\"pln\">                </span><span class=\"kwd\">if</span><span class=\"pln\"> </span><span class=\"pun\">(</span><span class=\"pln\">instance </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L7\"><code><span class=\"pln\">                    instance </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">();</span></code></li><li class=\"L8\"><code><span class=\"pln\">                </span><span class=\"pun\">}</span></code></li><li class=\"L9\"><code><span class=\"pln\">            </span><span class=\"pun\">}</span></code></li><li class=\"L0\"><code><span class=\"pln\">        </span><span class=\"pun\">}</span></code></li><li class=\"L1\"><code><span class=\"pln\">        </span><span class=\"kwd\">return</span><span class=\"pln\"> instance</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pln\">    </span><span class=\"pun\">}</span></code></li><li class=\"L3\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作</p>\r\n<p>枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的</p>\r\n</blockquote>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">enum</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pln\"> </span><span class=\"pun\">{</span></code></li><li class=\"L1\"><code><span class=\"pln\">    INSTANCE</span><span class=\"pun\">;</span></code></li><li class=\"L2\"><code><span class=\"pun\">}</span></code></li></ol></pre><blockquote>\r\n<p>通过枚举类获取单例的实例</p>\r\n<pre class=\"prettyprint linenums prettyprinted\"><ol class=\"linenums\"><li class=\"L0\"><code><span class=\"typ\">Singleton</span><span class=\"pln\"> result </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"typ\">Singleton</span><span class=\"pun\">.</span><span class=\"pln\">INSTANCE</span><span class=\"pun\">;</span></code></li></ol></pre></blockquote>\r\n<h3 id=\"h3--\"><a name=\"知识点：什么时候是类装载时？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>知识点：什么时候是类装载时？</h3><blockquote>\r\n<p>前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？</p>\r\n<p>不严格的说，大致有这么几个条件会触发一个类被加载：</p>\r\n<ol>\r\n<li>new一个对象时</li><li>使用反射创建它的实例时</li><li>子类被加载时，如果父类还没被加载，就先加载父类</li><li>jvm启动时执行的主类会首先被加载</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-u9002u7528u573Au666F\"><a name=\"适用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适用场景</h2><blockquote>\r\n<ul>\r\n<li>类只能有一个实例而且客户可以从一个众所周知的访问点访问它</li><li>这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><p>OK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？<br>可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……<br>但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D</p>\r\n<p>—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o<br>所以，尽力做到能做到的最好就行了。</p>\r\n<p>—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。</p>\r\n<h2 id=\"h2-u5F00u6E90u9879u76EE\"><a name=\"开源项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开源项目</h2><p>本人创建的关于各种设计模式的开源项目：<a href=\"https://github.com/JamesZBL/java_design_patterns\">Java 实现的面向对象软件设计模式</a>  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。</p>\r\n<p>原文链接：<a href=\"https://zhuanlan.zhihu.com/p/31007589\">Hi，我们再来聊一聊Java的单例吧</a></p>\r\n</div>', '## 前言\r\n单例(Singleton)应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\r\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\r\n\r\n## 什么是单例？\r\n单例对象的类必须保证只有一个实例存在——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\r\n>* 保证一个类仅有一个实例， 并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例。\r\n>* 这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求 ）， 并且它可以提供一个访问该实例的方法\r\n\r\n## 实例\r\n\r\n> 在一部电影中，导演的作用是至关重要的，通常一部电影只有一个总导演。在电影的拍摄过程中，可能会设计多个片场，导演需要对不同的演员进行分别指导，但所有演员导演都是同一个人，“把导演叫过来” 这个过程可以视为单例模式获取实例的过程\r\n\r\n## 模式分析\r\n\r\n> 先来看最简单的写法\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    public static Single getInstance() {\r\n        if (instance == null) {\r\n            instance = new Single();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n\r\n> 稍作修改，把构造器改为私有的，防止被外部的类调用\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> 每次获取实例对象之前先进行判空，如果对象为 null 则实例化一个 instance，如果存在则直接返回该实例。这种方法表面上看是完美的，仿佛实例只存在一个。但是，在多线程运行的时候，如果两个不同的线程同时运行到判空操作，会各自分别创建一个实例，这样一来，这种方法就不是单例了\r\n\r\n> 在 getInstance() 方法上添加 synchronized 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 这样写保证了 getInstance 方法同一时刻只会有一个线程执行，但是这样做会使得除了执行这个方法的线程顺利执行外，其他所有线程都要等待，这会造成极大的系统开销，降低了程序的运行效率\r\n\r\n> 这种方法代价过高，因为无论 instance 是否为 null ,每次执行时，整个方法都加上了锁，我们不妨将锁的范围尽可能的缩小，把对性能的影响降到最低，于是有了如下写法\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> 只有当 instance 为 null 的时候才执行同步代码块，二次判空保证了不会产生多个实例\r\n\r\n> 这样看似没问题了，但是在计算机中，有时为了提高运行效率，会对指令进行重拍，比如\r\n\r\n```\r\nint a;      //语句 A\r\na = 3;      //语句 B\r\nint b = 5;      //语句 C\r\nint c = a + b;  //语句 D\r\n```\r\n> 可能会被重排成 A-C-B-D 或者 C-A-B-D\r\n>\r\n> 语句 C 和语句 D 不具备原子性，因此也有可能被重排\r\n> getInstance 操作如果被重排，那么 instance 会存在一种 “不为 null 但是仍然未被初始化” 的状态，即已经给 instance 分配了内存空间但是并没有调用 Singleton 的构造方法来初始化 instance，执行判空的线程抢在了初始化的操作完成之前，则直接返回 instance 肯定会报错\r\n> \r\n> 于是有了最终版本，添加 volatile 关键字\r\n\r\n```\r\npublic class Singleton {\r\n    private static volatile Singleton instance;\r\n    private Singleton() {}\r\n    public static Singleton getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n} \r\n```\r\n> volatile 关键字具有屏蔽指令重排的功能，即对 instance 加上了一把锁，在完成写操作之前不会允许其他线程进行读操作，因此，在初始化完成前，无法对其进行读操作\r\n\r\n> 枚举类型是线程安全的，因此采用枚举类作为单例模式的一种实现是非常方便的\r\n\r\n```\r\npublic enum Singleton {\r\n    INSTANCE;\r\n}\r\n```\r\n\r\n> 通过枚举类获取单例的实例\r\n```\r\nSingleton result = Singleton.INSTANCE;\r\n```\r\n\r\n### 知识点：什么时候是类装载时？\r\n\r\n> 前面提到了单例在类装载时被实例化，那究竟什么时候才是『类装载时』呢？\r\n\r\n> 不严格的说，大致有这么几个条件会触发一个类被加载：\r\n> 1. new一个对象时\r\n> 2. 使用反射创建它的实例时\r\n> 3. 子类被加载时，如果父类还没被加载，就先加载父类\r\n> 4. jvm启动时执行的主类会首先被加载\r\n\r\n## 适用场景\r\n\r\n>* 类只能有一个实例而且客户可以从一个众所周知的访问点访问它\r\n>* 这个唯一实例应该是通过子类化可扩展的， 并且客户应该无需更改代码就能使用一个扩展的实例\r\n\r\n## 总结\r\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\r\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\r\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\r\n\r\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\r\n所以，尽力做到能做到的最好就行了。\r\n\r\n—— 感谢你花费了不少时间看到这里，但愿你没有觉得虚度。\r\n\r\n\r\n## 开源项目\r\n本人创建的关于各种设计模式的开源项目：[Java 实现的面向对象软件设计模式](https://github.com/JamesZBL/java_design_patterns)  ，如果觉得有用，欢迎 Star/Fork/提Issue。该项目目前处在开发阶段。\r\n\r\n原文链接：[Hi，我们再来聊一聊Java的单例吧](https://zhuanlan.zhihu.com/p/31007589)', '2017-12-09 18:07:40', '2017-12-09 18:07:40');

-- ----------------------------
-- Records of tag
-- ----------------------------
INSERT INTO `tag` VALUES ('13', 'SpringBoot', '2017-12-09 15:26:30', '2017-12-09 15:26:30');
INSERT INTO `tag` VALUES ('14', 'MyBatis', '2017-12-09 15:26:31', '2017-12-09 15:26:31');
INSERT INTO `tag` VALUES ('15', 'MVC', '2017-12-09 15:26:31', '2017-12-09 15:26:31');
INSERT INTO `tag` VALUES ('16', 'AOP', '2017-12-09 15:26:31', '2017-12-09 15:26:31');
INSERT INTO `tag` VALUES ('17', 'Servlet', '2017-12-09 23:51:56', '2017-12-16 15:42:45');

-- ----------------------------
-- Records of tag_article
-- ----------------------------
INSERT INTO `tag_article` VALUES ('2', '13', '24', '2017-12-09 15:26:31', '2017-12-09 15:26:31');
INSERT INTO `tag_article` VALUES ('3', '14', '24', '2017-12-09 15:26:31', '2017-12-09 15:26:31');
INSERT INTO `tag_article` VALUES ('4', '15', '24', '2017-12-09 15:26:31', '2017-12-09 15:26:31');
INSERT INTO `tag_article` VALUES ('5', '16', '24', '2017-12-09 15:26:31', '2017-12-09 15:26:31');
INSERT INTO `tag_article` VALUES ('6', '17', '24', '2017-12-09 23:52:12', '2017-12-09 23:52:12');
INSERT INTO `tag_article` VALUES ('7', '17', '23', '2017-12-09 23:54:21', '2017-12-09 23:54:21');
INSERT INTO `tag_article` VALUES ('8', '13', '22', '2017-12-09 23:58:14', '2017-12-16 15:43:34');

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES ('23', 'ZBL', '4d8812dbb1bc41c2d4af4a9967bff7a7', null, 'ZBL', null, null, null, null, null, null, null, null, '0', '0', '2017-12-06 18:48:37', '2017-12-08 23:54:00');
INSERT INTO `user` VALUES ('25', '18333298410', '5b3ea3a80775c95c608cd3c220f2a754', null, '18333298410', null, null, null, null, null, null, null, null, '0', '0', '2017-12-09 00:06:36', '2017-12-16 15:43:53');
